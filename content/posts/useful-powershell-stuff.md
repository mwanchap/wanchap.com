+++
title = "Useful Powershell stuff"
date = 2017-09-27T15:37:00Z
updated = 2019-12-12T21:38:37Z
tags = ["Powershell"]
blogimport = true 
[author]
	name = "Matt Wanchap"
	uri = "https://www.blogger.com/profile/16465307324394182190"
+++

Group objects into batches of X items with a constructed property, credit to <a href="https://stackoverflow.com/a/26850233" target="_blank">Dave Wyatt</a>:<br /><br />$bigList = 1..1000<br />$counter = [pscustomobject] @{ Value = 0 }<br />$groupSize = 100<br />$groups = $bigList | Group-Object -Property { [math]::Floor($counter.Value++ / $groupSize) }<br /><br />-----<br />Use "PipelineVariable" to pass data down the pipeline rather than using a foreach:<br /><br />Get-ADUser &lt;username&gt; -PipelineVariable user -Properties memberof |<br />&nbsp; &nbsp; Select-Object -ExpandProperty memberof |<br />&nbsp; &nbsp; &nbsp; &nbsp; Select-Object @{ n = 'Name'; e = { $user.Name }}, @{ n = 'MemberOf' ; e = { $PSItem -replace 'CN=|,(OU|CN)=.+' }}<br /><div><br /></div><div>Also if a cmdlet does not support -pipelineVariable you can pass it to Where-Object</div><div><div><br /></div><div>Get-Mailbox -ResultSize Unlimited | Where-Object {$true} -PipelineVariable mbx | whatever</div></div><div><br /></div>-----<br />Convert a list of strings into a single line string delimited by quotes and separated by commas, suitable for using in a "IN" statement in SQL/SOQL<br /><br />$ids is a list of ID strings<br />$idsString = $ids -replace "(\w+)",'''$1'''&nbsp; -join ','<br />or if it's one large string separated by line breaks (e.g. copied from a spreadsheet):<br />$idsString = ($ids -replace "(\w+)",'''$1''').Split("`n") -join ','<br /><br />-----<br />Print a line<br />'_' * 100<br /><br />Prevent null references, incorrect syntax usage, unnamed variables:<br />Set-StrictMode -Version Latest<br /><br />Creating a new instance of a .net framework object<br />New-Object TypeName "System.Diagnostics.Stopwatch"<br />Or more simply, New-Object System.Diagnostics.Stopwatch<br />Because it's a string, don't use the type name in angle brackets like PS normally would<br /><br />To view absolutely everything that's happening internally in the powershell pipeline for a particular scriptblock:<br />Trace-Command -Name * -Expression {Get-Service winrm | Restart-Service} -PSHost<br /><br />Add a calculated property to a list of objects, along with all the other properties:<br />&nbsp; &nbsp; Select *,@{Name="ExtraField"; Expression={$_.SomeValue+1}}, @{Name="Whatever"; Expression={"Some string"}}<br /><br />Get a list of drives, including network drives and their UNC paths (like with "net use"):<br />&nbsp; &nbsp; Get-WmiObject -Class win32_logicaldisk<br /><br />Get previous session history with "get-history"<br />Run a previous command without pushing up 1000 times with "invoke-history"<br /><br />csi = C# interactive (custom alias)<br /><br />Formatting:<br />get a list of every property and value for an object:<br />&nbsp; &nbsp; $whatever | Format-List<br />Prevent output from truncating:<br />&nbsp; &nbsp; Format-Table -AutoSize -Wrap<br /><br />Redirection:<br />&amp; { blah } 1 &gt; $null&nbsp; &nbsp; - suppress standard output from executing "blah". <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_redirection" target="_blank">More info</a><br />$var = &amp; Do-Stuff *&gt;&amp;1&nbsp; - redirect all output to standard output and store that in $var<br />&amp; { whatever } 2&gt;$null 3&gt;$null - redirect error and warning streams<br /><br />Output:<br />get-content .\somefile -Wait&nbsp; - tail-like behaviour, displays additions to the file<br />get-content | more&nbsp; - allows paging of output<br /><br />Getting a count of duplicated things:<br />$whatever | group FieldToGroup | where Count -gt 1 | sort Count -Descending | select Name, Count<br /><br />set-clipboard (scb) - sets the contents of the clipboard to whatever is pasted in.&nbsp; Useful with sls for non-powershell commands that output text that you have to use in another command<br /><br />Delimiters<br />`t - tab<br /><br />When using delimiters with "Import-Csv -Delimiter", make sure not to surround them with quotes<br /><br />cd env:&nbsp; &nbsp; gets environment vars<br />get-psprovider&nbsp; &nbsp; lists providers<br />get-psdrive&nbsp; &nbsp; lists drives<br />get-module -listavailable&nbsp; &nbsp; lists all available modules<br /><br />hashtable of variables for passing in parameters<br />$parameters = @{<br />&nbsp; &nbsp; 'param1' = $value1<br />&nbsp; &nbsp; 'param2' = $value2<br />}<br /><br />Run-SomeCmdlet @parameters&nbsp; &nbsp; &nbsp;&lt;- notice the @ symbol, not $<br /><br />write-verbose lines in a function only write if a -verbose flag was provided to the function<br /><br />@($a) forces $a to be in an array<br /><br />use regexes with "where" with the "match" operator:<br />&nbsp; &nbsp; gci | where name -match '\d{2}'<br /><br />rename properties for a select:<br />&nbsp; &nbsp; &nbsp; &nbsp; ps | select @{Name='Title';Exp={$_.ProcessName}}<br /><br />select-string (alias: sls)<br />&nbsp; &nbsp; very useful for selecting strings from a whole bunch of string-based output<br />&nbsp; &nbsp; works like grep in linux<br />&nbsp; &nbsp; &nbsp; &nbsp; ipconfig | sls subnet<br /><br />To use IIS stuff:<br />&nbsp; &nbsp; Import-Module WebAdministration<br />open IIS drive and navigate to a website:<br />&nbsp; &nbsp; cd IIS:\<br />&nbsp; &nbsp; cd sites\sitename<br /><br />Get a list of every module<br />&nbsp; &nbsp; Get-Module -ListAvailable<br />Find a module based on name<br />&nbsp; &nbsp; Get-Module *web*<br />Find all commands in a module<br />&nbsp; &nbsp; Get-Command -Module WebAdministration<br /><br />get current item members:<br />&nbsp; &nbsp; gi . | gm<br />recycle an app pool by navigating to it<br />&nbsp; &nbsp; cd IIS:\AppPools\somewebsite<br />&nbsp; &nbsp; (gi .).Recycle()<br />or also in one line:<br />&nbsp; &nbsp; (gi IIS:\AppPools\somewebsite).Recycle()<br /><br />ii (invoke-item)<br />&nbsp; &nbsp; performs the default action on an item, e.g. opens a file using a program<br /><br />-join operator, joins strings together<br />&nbsp; &nbsp; when used first (unary), joins without delimiting<br />&nbsp; &nbsp; &nbsp; &nbsp; -join ("asdf", "qwer") #outputs asdfqwer<br />&nbsp; &nbsp; when used as a binary operator, allows a delimiter<br />&nbsp; &nbsp; &nbsp; &nbsp; ("asdf", "qwer") -join '-' #outputs asdf-qwer<br /><br />-replace operator, using regex to replace strings<br />&nbsp; &nbsp; replace pairs of html tags with &lt;small&gt;:<br />&nbsp; &nbsp; &nbsp; &nbsp; $foo = $foo -replace '&lt;(\/)?\w+&gt;', '&lt;$1small&gt;'<br /><br />searching application event log for a particular guid:<br />&nbsp; &nbsp; Get-EventLog -logname application | where {$_.Message -ilike "*6CD27361-D038-E611-9B7F-005056956605*") } | select message
